#!/usr/bin/env python3
from pathlib import Path
from datetime import datetime

class CanMessage:
    def __init__(self, message_id: int, message_name: str, message_length: int, message_signals: list['CanSignal']):
        self.message_id = message_id
        self.message_name = message_name
        self.message_length = message_length
        self.message_signals = message_signals

class CanSignal:
    def __init__(self, signal_message: CanMessage, signal_name: str, signal_bitpos: int, signal_bitlength: int, signal_scale_factor: float, signal_offset: float):
        self.signal_name = signal_name
        self.signal_bitpos = signal_bitpos
        self.signal_bitlength = signal_bitlength
        self.signal_scale_factor = signal_scale_factor
        self.signal_offset = signal_offset
        self.signal_message = signal_message

class Dbc:
    def __init__(self, dbc_file):
        self.dbc_file = dbc_file
        self.messages = {}
        self.signals = {}
        self.parse_dbc()
    def parse_dbc(self):
        with open(self.dbc_file, 'r') as f:
            current_message : CanMessage|None = None
            for line in f:
                if line.startswith('BO_'):
                    current_message = self.add_message(line)
                elif line.startswith(' SG_'):
                    if current_message is not None:
                        self.add_signal(line, current_message)
                    else:
                        raise ValueError('Signal without message')
    def add_message(self, line: str) -> CanMessage:
        message_id, message_name, message_length = line.split()[1:4]
        if message_name.endswith(':'):
            message_name = message_name[:-1]
        message_signals = []
        self.messages[message_id] = CanMessage(int(message_id), message_name.strip(), int(message_length), message_signals)
        return self.messages[message_id]
    def add_signal(self, line: str, message: CanMessage):
        signal_name, _colon, signal_bitfield, signal_factor_and_offset = line.split()[1:5]
        bitpos, rest = signal_bitfield.split('|')
        bitlength, _ = rest.split('@')
        signal_scale_factor, signal_offset = signal_factor_and_offset.strip('()').split(',')
        signal = CanSignal(message, signal_name, int(bitpos), int(bitlength), float(signal_scale_factor), float(signal_offset))
        message.message_signals.append(signal)
        self.signals[signal_name] = signal

def generate_can_messages_h(dbc: Dbc, file: Path):
    gentime = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    generated_code_comment = \
        f'''//-------------------------------
// File generated by generate_can_code.py on: {gentime}
//-------------------------------\n\n'''

    bitfield_type = 'uint64_t'

    with open(file, 'w') as f:
        f.write(generated_code_comment)
        f.write('#ifndef INC_CAN_MESSAGES_H_\n')
        f.write('#define INC_CAN_MESSAGES_H_\n\n')
        f.write('#include "can_db.h"\n\n')

        # Generate packed attribute macro for different compilers
        f.write('#ifdef __GNUC__\n')
        f.write('#define PACKED __attribute__((packed))\n')
        f.write('#else\n')
        f.write('#define PACKED\n')
        f.write('#endif\n\n')

        # Generate a struct for each message
        for message in dbc.messages.values():
            f.write(f'#define CAN_DB_{message.message_name.upper()}_ID {message.message_id}\n')
            f.write('typedef union {\n    uint64_t as_u64;\n    struct PACKED {\n')

            # Track current bit position in message
            current_bit = 0

            # Sort signals by bit position for consistent layout
            sorted_signals = sorted(message.message_signals, key=lambda s: s.signal_bitpos)

            for signal in sorted_signals:
                # If there's a gap between signals, add a reserved field
                if signal.signal_bitpos > current_bit:
                    gap_size = signal.signal_bitpos - current_bit
                    f.write(f'        {bitfield_type} _reserved{current_bit} : {gap_size};\n')

                # Add the signal bitfield
                f.write(f'        {bitfield_type} {signal.signal_name} : {signal.signal_bitlength};\n')
                current_bit = signal.signal_bitpos + signal.signal_bitlength

            # If there are remaining bits to the end of the message byte boundary, add final reserved field
            total_bits = message.message_length * 8
            if current_bit < total_bits:
                f.write(f'        {bitfield_type} _reserved{current_bit} : {total_bits - current_bit};\n')

            f.write(f'    }} fields;\n}} CANMessage_{message.message_name};\n\n')

        # Generate the original signal arrays as well
        for message in dbc.messages.values():
            f.write(f'#define CAN_DB_{message.message_name.upper()}_SIGNAL_COUNT {len(message.message_signals)}\n')
            f.write(f'static const CANDatabaseSignal_t can_db_signals_{message.message_name}')
            f.write(f'[CAN_DB_{message.message_name.upper()}_SIGNAL_COUNT] = {{\n')

            for signal in message.message_signals:
                bitmask = (1 << signal.signal_bitlength) - 1
                f.write(f'    {{.name = "{signal.signal_name}", ')
                f.write(f'.bitpos = {signal.signal_bitpos}, ')
                f.write(f'.bitmask = 0x{bitmask:X}ULL}},\n')

            f.write('};\n\n')

        # Define message count and messages array
        f.write(f'#define CAN_DB_MESSAGE_COUNT {len(dbc.messages)}\n')
        f.write('static const CANDatabaseMessage_t can_db_messages[CAN_DB_MESSAGE_COUNT] = {\n')

        for message in dbc.messages.values():
            f.write(f'    {{.name = "{message.message_name}", ')
            f.write(f'.can_id = {message.message_id}, ')
            f.write(f'.num_signals = CAN_DB_{message.message_name.upper()}_SIGNAL_COUNT, ')
            f.write(f'.signals = (CANDatabaseSignal_t*)can_db_signals_{message.message_name}}},\n')

        f.write('};\n\n')
        f.write('#endif /* INC_CAN_MESSAGES_H_ */\n')

if __name__ == '__main__':
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument('dbc_file', type=Path)
    parser.add_argument('header_file_path', type=Path)
    args = parser.parse_args()
    dbc_path = args.dbc_file
    header_path = args.header_file_path
    dbc = Dbc(dbc_path)
    generate_can_messages_h(dbc, header_path)
